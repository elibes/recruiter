# recruiter-iv1201
This is a CSR application built for [Amusement Park] that will be used for recruiting new staff.

## Key functionality
The recruitment application allows for two types of users: regular applicants and recruiters. A user can register an account with the recruitment application, and then they become an applicant. For a user to become a recruiter, the role_id of their account must be manually edited (from 2 to 1) with a query to the database. 

When a user logs in to the recruitment application they will be sent to a page where they can submit an application if they are an applicant, or to a page where they can list all applications stored in the database if they are a recruiter. Individual applications cannot be shown in full detail, and they cannot be approved or rejected. An applicant cannot use the recruiter page to list applications, and a recruiter cannot use the application page to send in an application. The role of the user is stored in the state of the client-side application to prevent them from navigating to a page they are not authorized to use, and a JSON Web Token containing the role (generated by the server and sent to the client when logging in) is sent to the server when trying to send an application and when listing all applications to verify that the user is authorized. 

The password of a user is encrypted by the server before being stored in the database when registering an account.

A CORS configuration is necessary for communication between server and client. The server application allows GET, POST, PUT, and DELETE requests from one origin specified by environment variables. For the web browser to accept the JWT sent by the server, its cookie options must have same-site set to 'none' (allowing it to come from a separate domain) and secure set to 'true' (requiring it to be sent over HTTPS, except for localhost).

The client features basic validation of entered data, such as necessary fields being filled or passwords matching when registering an account. Further validation, such as passwords being strong enough or emails having a valid format, is done by the server and sent to the client where it can be displayed to the user. 

The client supports localization for English and Swedish. The website uses English by default, but will use Swedish if it detects that the browser is using it. The user can also specify the language manually. Localizations are stored on the server, and fetched by the client as needed.

The application has been tested to work in Google Chrome, Mozilla Firefox, Microsoft Edge, and Apple Safari.

## Architectural overview:

The application is split into a front-end responsible for the UI, and a backend responsible for everything else.

Front-end layers:

* **View** - Containing the interfaces that the user interact with.
* **ViewModel** - The brain of the front-end. Handling user input from the view layer and providing it with data from the model layer. 
* **Model** - The data source, responsible for getting data from the back-end.
* **Router** - Handles the concerns of navigation and flow control.
* **Util** - For cross-cutting concerns, like error handling.

Back-end layers:

* **Api** - Responsible for functionality related to directly interacting with the outside and managing the HTTP request-response cycle.
* **Service** - The brain of the application, Handling buinsess logic and decision making. Also handles data flow between api and integration.
* **Integration** - Abstracts the logic required to access the database.
* **Model** - Contains definitions of domain model objects.
* **Utilities** - For cross-cutting concerns, like error handling and validation.

## Technologies used

The application is split into a front-end and a back-end api both of which uses Typescript and Node.js.

### Shared technologies:
* **npm** - Used to install, manage and share project dependencies.
* **ESLint, Prettier, Google typescript styleguide** - A combination of tools to enforce code quality and consistency.
* **nodemon** - A utility that automatically restarts node.js when changes are detected in the source files.
* **date-fns** - A library for handling date and time manipulation.
* **dotenv-safe** - A tool to load enviroment variables, to ensure sensitive configuration is omitted from version control.

### Back-end technologies:
* **Express (and various middleware)** - The core web framework for building the API.
* **Sequelize** - An ORM to simplify interaction with the database.
* **PostgresSQL** - The DBMS used for the database.
* **Brcypt** - Hashes and salts passwords for secure storage.
* **validator.js** - A library containing various string validators.
* **decimal.js** - A library to add a decimal type to javascript.

### Front-end technologies:
* **React (via create react app)** - A library for building interactive UI.
* **Redux (redux-toolkit)** - For state management
* **i18next** - A framework to aide in internationalization of web pages.
* **Fetch API** - To communicate with the back-end server.

## Building
The application is separated into two parts: the server application, and the client application. The two parts are built and launched separately.
Note that both the server and client requires environment variables. When running locally, you can copy the values from the `.env.example` file to a `.env` file in the same directory. If your database is configured differently than specified in the `.env.example` for the server you will need to make changes accordingly in the `.env` file.
### Server

#### Development build
A development build will reload when changes in the code are dected, but will not be as optimized as a production build.
1. Navigate to the `server` directory from the root of the project.
2. Run `npm install` to install all dependecies specified in `package.json`.
3. Run `npm run dev` to start the server.

#### Production build
A production build has better optimization than a development build, and can be run locally to verify that the application works before deploying.
1. Navigate to the `server` directory from the root of the project.
2. Run `npm install` to install all dependecies specified in `package.json`.
3. Run `npm run build` to create an optimized production build in the `build` directory.
4. Run `npm start` to run the build from stored in `build`.

### Client
#### Development build
A development build will reload when changes in the code are dected, but will not be as optimized as a production build.
1. Navigate to the `client` directory from the root of the project.
2. Run `npm install` to install all dependecies specified in `package.json`.
3. Run `npm start` to start the client.

#### Production build
A production build has better optimization than a development build, and can be run locally to verify that the application works before deploying.
0. Make sure you have a static server installed, such as `serve` (`npm install -g serve`)
1. Navigate to the `client` directory from the root of the project.
2. Run `npm install` to install all dependecies specified in `package.json`.
3. Run `npm run build` to create an optimized production build in the `build` directory.
4. Start the client by running the build stored in `build` (with `serve`, run `serve -s build`).

## Deploying
This will show how to set up a deployment using [render](https://render.com/).

### Database
0. Make sure you have psql installed on your system.
1. Follow [this guide](https://docs.render.com/databases#create-your-database) up to when you create the database.
2. Click the "Connect" button (top right of the screen), select the "External connection" tab, and copy the PSQL command.
3. Open your terminal and paste the command to connect to the database remotely.
4. Run `\i [path to database dump]` to restore your dump of the database on your render database.
5. Disconnect from the database with `\q`.

### Server
Follow [this guide](https://docs.render.com/web-services#deploy-from-github--gitlab) to set up a *web service* for hosting the server.
Note the following:
* When choosing a repository select this one.
* Select the `main` branch when asked.
* Select Node.js as the runtime.
* Write `server` as the root directory.
* Write `npm install` as the build script.
* Write `npm start` as the start script.

You will then need to specify the following environment variables:
* `CORS_URL`: Write the URL of the client.
* `DB_DIALECT`: Write `postgres`.
* `DB_HOST`: Copy and paste the "Hostname" from **Info > Connection** for your render database.
* `DB_NAME`: Copy and paste the "Database" from **Info > Connection** for your render database.
* `DB_PASSWORD`: Copy and paste the "Password" from **Info > Connection** for your render database.
* `DB_PORT`: Copy and paste the "Port" from **Info > Connection** for your render database.
* `DB_USER`: Copy and paste the "Username" from **Info > Connection** for your render database.
* `JWT_SECRET`: Press "Generate" to create a random string, or specify your own.

You can now click **Manual Deploy > deploy latest commit** to deploy the server.

### Client
Follow [this guide](https://docs.render.com/deploy-create-react-app) to set up a *static website* for hosting the client application.
Note the following:
* Select the `main` branch when asked.
* Write `client` as the root directory.
* For the build command, write `npm install; npm run build`.
* For the publish directory, write `./build`.
* Make sure to follow the "Using Client-Side Routing" part of the guide.

You will then need to specify the following environment variable:
* `REACT_APP_SERVER_URL`: Write the URL of the server.

You can now click **Manual Deploy > deploy latest commit** to deploy the server.

### Automatically deploy client and server with CI/CD
TODO:

copy the deploy hooks from **Settings > Build & Deploy** of the server and client on render, and store as [X] on github.  
